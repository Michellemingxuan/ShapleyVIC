% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_shapley_vic.R
\name{compute_sage_value}
\alias{compute_sage_value}
\title{Compute SAGE values for a model}
\usage{
compute_sage_value(
  model_py,
  x_test,
  y_test,
  coef_vec = NULL,
  var_names = NULL,
  check_convergence = FALSE
)
}
\arguments{
\item{model_py}{A Python callable model object that has a
\code{predict_proba} function.}

\item{x_test}{A \code{data.frame} of predictors from the test set. Make sure
categorical variables are properly encoded as factors.}

\item{y_test}{A numeric vector of outcome from the test set, with events
coded as 1.}

\item{coef_vec}{Numeric vector of model coefficients (including the
intercept term as the first element), to replace the coefficients in
\code{model_py}. Default is \code{NULL}, where the coefficients in
\code{model_py} will be used.}

\item{var_names}{String vector of variable names (not the names of regression
coefficients, if categorical variables are involved). If unspecified,
column names of \code{x_test} will be used.}

\item{check_convergence}{Whether to check convergence in SAGE algorithm (may
slightly slow done the algorithm). Default is \code{FALSE}.}
}
\value{
Returns a \code{data.frame} containing variable names, SAGE values
  and their standard deviations.
}
\description{
Compute SAGE values for a model
}
\examples{
data("df_compas", package = "ShapleyVIC")
head(df_compas)
# The following requires python libraries sage and sklearn, otherwise NULL is
# returned. Small training and test sets are used to reduce run time.
m_optim <- ShapleyVIC::logit_model_python(x_train = df_compas[1:1000, -1],
                                          y_train = df_compas$y[1:1000])
if (!is.null(m_optim)) {
  ShapleyVIC::compute_sage_value(model_py = m_optim,
                                 var_names = names(df_compas)[-1],
                                 x_test = df_compas[1001:1100, -1],
                                 y_test = df_compas$y[1001:1100])
}
}
