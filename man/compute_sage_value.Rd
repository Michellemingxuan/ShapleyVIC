% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_shaply_vic.R
\name{compute_sage_value}
\alias{compute_sage_value}
\title{Compute SAGE values for a model}
\usage{
compute_sage_value(
  model_py,
  coef_vec = NULL,
  var_names = NULL,
  x_test,
  y_test,
  check_convergence = FALSE
)
}
\arguments{
\item{model_py}{A callable model object to pass to Python.}

\item{coef_vec}{Named numeric vector of model coefficients. The first element
should be the intercept term.}

\item{var_names}{String vector of name of model coefficients. Default is
\code{NULL}, in which case \code{names(coef_vec)} will be used.}

\item{x_test}{Numeric design matrix of predictors.}

\item{y_test}{Integer vector of outcome, preferably coded as 1 (event) vs -1
(non-event).}

\item{check_convergence}{Whether to check convergence in SAGE algorithm (may
slightly slow done the algorithm). Default is \code{FALSE}.}
}
\value{
Returns a \code{data.frame} containing model class, model
  coefficients and their names, SAGE values and their standard deviations.
  Note that SAGE value and standard deviation is not defined for the
  intercept and therefore will be \code{NA}.
}
\description{
Compute SAGE values for a model
}
\examples{
data("df_compas", package = "ShapleyVIC")
head(df_compas)
# The following requires python libraries sage and sklearn, otherwise NULL is
# returned. Small training and test sets are used to reduce run time.
m_optim <- ShapleyVIC::logit_model_python(x_train = df_compas[1:1000, -1],
                                          y_train = df_compas$y[1:1000])
if (!is.null(m_optim)) {
  ShapleyVIC::compute_sage_value(model_py = m_optim,
                                 var_names = names(df_compas)[-1],
                                 x_test = df_compas[1001:1100, -1],
                                 y_test = df_compas$y[1001:1100])
}
}
