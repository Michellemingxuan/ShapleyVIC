% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_shapley_vic.R
\name{compute_sage_value}
\alias{compute_sage_value}
\title{Compute SAGE values for a model}
\usage{
compute_sage_value(
  model_py,
  coef_vec = NULL,
  var_names = NULL,
  x_test,
  y_test,
  check_convergence = FALSE
)
}
\arguments{
\item{model_py}{A Python callable model object that has a
\code{predict_proba} function.}

\item{coef_vec}{Named numeric vector of model coefficients (including the
intercept term as the first element), to replace the coefficients in
\code{model_py}. Default is \code{NULL}, where the coefficients in
\code{model_py} will be used.}

\item{var_names}{String vector of name of model coefficients. Default is
\code{NULL}, in which case \code{names(coef_vec)} will be used.}

\item{x_test}{A \code{data.frame} of predictors from the test set. Make sure
categorical variables are properly encoded as factors.}

\item{check_convergence}{Whether to check convergence in SAGE algorithm (may
slightly slow done the algorithm). Default is \code{FALSE}.}
}
\value{
Returns a \code{data.frame} containing model class, model
  coefficients and their names, SAGE values and their standard deviations.
  Note that SAGE value and standard deviation is not defined for the
  intercept and therefore will be \code{NA}.
}
\description{
Compute SAGE values for a model
}
\examples{
data("df_compas", package = "ShapleyVIC")
head(df_compas)
# The following requires python libraries sage and sklearn, otherwise NULL is
# returned. Small training and test sets are used to reduce run time.
m_optim <- ShapleyVIC::logit_model_python(x_train = df_compas[1:1000, -1],
                                          y_train = df_compas$y[1:1000])
if (!is.null(m_optim)) {
  ShapleyVIC::compute_sage_value(model_py = m_optim,
                                 var_names = names(df_compas)[-1],
                                 x_test = df_compas[1001:1100, -1],
                                 y_test = df_compas$y[1001:1100])
}
}
